
An Integrated Approach to Object-Oriented
Software Design
Brahma Dathan Sarnath Ramnath
January 3, 2020
2
Contents
4 Analyzing a System 5
4.1 Gathering the Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
4.1.1 The Library Case Study . . . . . . . . . . . . . . . . . . . . . . . . . 6
4.2 Building the User-Interaction Model . . . . . . . . . . . . . . . . . . . . . . . 8
4.2.1 Use Case Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
4.2.2 Detailed Use Cases for the Library System . . . . . . . . . . . . . . . 11
4.3 Defining Conceptual Classes and Relationships . . . . . . . . . . . . . . . . . 18
4.3.1 Conceptual Classes for the Library System . . . . . . . . . . . . . . . 21
4.3.2 Identifying the Relationships Between the Classes . . . . . . . . . . . 23
4.4 Using the Knowledge of the Domain . . . . . . . . . . . . . . . . . . . . . . . 28
4.5 Discussion and Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.6 Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
4.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
3
4
Chapter 4
Analyzing a System
Analysis is a fundamental part of any problem solving process. In our case, the solution we
seek is a piece of software, developed using the object-oriented methodology. This solution
consists several classes and their instances, interacting with each other to achieve the desired
result. Before any programming effort, it is therefore essential to identify the classes and the
manner in which these classes and their instances interact. The process of analysis helps us
extract this information from the the problem requirements.
At the enterprise level, when new software is to be developed, considerable effort has to
be expended to gather all the requirements. These are spelled out in a document known
variously as “The Requirements Specification,” “System Requirements,” etc. Using these,
the system analyst creates a model of the system, enabling the identification of some of the
components of the system and the relationships between them. The end product of this phase
is a user-interaction model which describes the functionality of the system and the manner
in which it interacts with the user, and a conceptual model for the system, which identifies
the conceptual entities, and describes the nature of the associations between these entities.
We can view the analysis process as a combination of the following three activities:
1. Gathering the requirements. This involves interviews of the user community, reading
of any available documentation, etc.
2. Precisely specifying the functionality required of the system, and the manner in which
it interacts with the user.
3. Developing a conceptual model of the system, listing the conceptual classes and their
relationships.
It is not always the case that these activities occur in the order listed. In fact, as the analysts
gather the requirements, they will analyze and document what they have collected. This may
point to holes in the information, which may necessitate further requirements collection.
This chapter uses a case study of a a library system, to explain the process of analysis. We
go through the processes of requirement specification, precise documentation of functionality,
and development of the conceptual model.
5
6
4.1 Gathering the Requirements
The purpose of requirements analysis is to define what the new system should do. The
importance of doing this correctly cannot be overemphasized. Since the system will be built
based on the information garnered in this step, any errors made in this stage will result in
the implementation of a wrong system. Once the system is implemented, it is expensive to
modify it to overcome the mistakes introduced in the analysis stage.
Imagine the scenario when you are asked to construct software for an application. The client
may not always be clear in his/her mind as to what should be constructed. One reason for
this is that it is difficult to imagine the workings of a system that is not yet built. Only when
we actually use a specific application such as a word processor, we start realizing the power
and limitations of that system. Before actually dealing with it, one may have some general
notions of what one would like to see, but may find it difficult to provide many details.
Incompleteness and errors in specifications can also occur because the client does not have
the technical skills to fully realize what technology can and cannot deliver. Once again, the
general concepts can be stated, but specifics are harder. A third reason for omissions is that
it is all too common to have a client who knows the system very well and consequently either
assumes a lot of knowledge on the part of the analyst or simply skips over “obvious details.”
Requirements for a new system are determined by a team of analysts by interacting with
teams from the company paying for the development (clients) and the user community, who
ultimately uses the system on a day-to-day basis. This interaction can be in the form of
interviews, surveys, observations, study of existing manuals, etc.
Broadly speaking, the requirements can be classified into two categories:
• Functional Requirements: These describe the interaction between the system and its
users, and between the system and any other systems, which may interact with the
system by supplying or receiving data.
• Non-Functional Requirements: Any requirement that does not fall in the above category
is a non-functional requirement. Such requirements include response time, usability, and
accuracy. Sometimes, there may be considerations that place restrictions on system
development; these may include the use of specific hardware and software and budget
and time constraints.
It should be mentioned that initiating the development cycle for a software system is usually
preceded by a phase that includes the initial conception and planning. A developer would be
approached by a client who wishes to have a certain product developed for his/her business.
There would be a domain associated with the business, which would have its own jargon.
Before approaching the developer, one would assume that the client has determined that a
need for a product exists. Once all these issues are sorted out, the developer(s) would meet
with the client and, perhaps several would-be end-users, to determine what is expected of
the system. Such a process would result in a list of requirements of the system.
4.1.1 The Library Case Study
Let us proceed under the assumption that the requirements have been gathered, and the
developers of our library system have available to them a document that describes how
the business is conducted. This functionality is described as a list of what are commonly
7
called business processes. For simplicity, all interaction with the system happens through
a designated individual, i.e, the clerk. It is also assumed that human actors will follow-up
on the interactions and perform the necessary follow-up actions. The system also does not
have the ability to perform specialized tasks like generating the call numbers for the Dewey
Decimal system. The business processes of the library system are listed below.
• Register new members. The library receives applications from people who want to
become library members, whom we alternatively refer to as users. While applying for
membership, a person supplies his/her name, phone number, and address to the library.
The system records all this information and assigns each member a unique identifier
(ID), which is needed for transactions such as issuing books.
• Add books to the collection. We will make the assumption that the collection
includes just books. For each book, the system stores the title, the author’s name, and
a unique ID. The ID is generated externally, i.e., provided as input to the system. (For
simplicity, let us assume that there is only one author per book. If there are multiple
authors, let us say that the names will have to be concatenated to get a pretty huge
name such as “Brahma Dathan and Sarnath Ramnath.” As a result, to the system, it
appears that there is still just one author.) When it is added to the collection, a book
is given a unique identifier by the clerk. This ID is based on some standard system of
classification.
• Issue a book(s) to a member(or user). To check out books, a user (or member)
must identify himself to a clerk and hand over the books. The clerk inputs the IDs,
and the system keeps track that the books have been checked out to the member. Any
number of books may be checked out in a single transaction.
• Record the return of a book. To return a book, the member gives the book to
a clerk, who submits the information to the system, which marks the book as “not
checked out.” If there is a hold on the book, the system should remind the clerk to set
the book aside so that the hold can be processed.
• Remove books from the collection From time to time, the library may remove
books from its collection. This could be because the books are worn-out, are no longer
of interest to the users, or other sundry reasons. The clerk inputs the ID, and system
verifies that it is safe to remove the book.
• Print out a user’s transactions. There may be a need to check the interactions
(book checkouts, returns, etc.) between a specific user and the library on a certain
date. The clerk provides the user’s ID and a date; the system displays the relevant
information.
• Place/remove a hold on a book. When a user wants to put a hold, he/she supplies
the clerk with the book’s ID, the user’s ID, and the number of days after which the
book is not needed. The clerk inputs this information, and the system adds the user
to a list of users who wish to borrow the book. If the book is not checked out, a hold
cannot be placed. To remove a hold, the system should be provided with the book’s ID
and the user’s ID.
• Renew books issued to a member. Customers may walk in and request that several
of the books they have checked out be renewed (re-issued). The clerk inputs the user’s
8
ID; the system displays the relevant books, allows the clerk to make a selection, and
displays the result.
• Notify member of book’s availability. Customers who had placed a hold on a book
are notified when the book is returned. This process is done once at the end of each
day. The clerk enters the ID for each book that was set aside, and the system returns
the name and phone number of the user who is next in line to get the book.
In addition, the system must support three other requirements that are not directly related
to the workings of a library, but, nonetheless, are essential.
• A command to save the data on a long-term basis.
• A command to load data from a long-term storage device.
• A command to quit the application. At this time, the system must ask the user if data
is to be saved before termination.
To keep the process simple, we restrict our attention for the time being to the above operations. A real library would have to perform additional operations like generating reports of
various kinds, impose fines for late returns, etc. Many libraries also allow users to check out
books themselves without approaching a clerk. Whatever the case may be, the analysts need
to learn the existing system and the requirements. As mentioned earlier, they achieve this
through interviews, surveys, and study.
Our goal here is to present the reader with the big picture of the entire process so that
the beginner is not overwhelmed by the complexity or bogged down in minutiae. Keeping
this in mind, we will be designing a system that the reader may find somewhat simplistic,
particularly if one compares this with the kinds of features that a “real” system in today’s
market can provide. While there is some truth to this observation, it should be noted that
the simplification of the system has been done with a view to reducing unnecessary detail so
that we can focus instead on the development process, elaborate on the use of tools described
previously, and explain through an example how good design principles are applied. In the
course of applying the above, we come with a somewhat simplified sample development process
that may be used as a template by someone who is getting started on this subject.
Assuming that we have a good grasp of the requirements, we need to document the functional requirements of the application and determine the system’s major entities and their
relationships.
4.2 Building the User-Interaction Model
It is important that the requirements be precisely documented. The requirements specification document serves as a contract between the users and the developers. When it is time
to deliver the system, there should be no confusion as to what the expectations are. Equally
or perhaps even more important, it also tells the designers the expected functionality of the
system. Moreover, as we attempt to create a precise documentation of the requirements, we
will discover errors and omissions.
An accepted way of accomplishing this task is use case analysis, which we study now.
9
4.2.1 Use Case Analysis
Use case analysis is a case-based way of describing the uses of the system with the goal of
defining and documenting the system requirements. It is essentially a narrative describing
the sequence of events (actions) of an external agent (actor) using the system to complete a
process. It is a powerful technique that describes the kind of functionality that a user expects
from the system. Use cases have two or more parties: agents who interact with the system
and the system itself. In our simple library system, the members do not use the system
directly. Instead, they get services via the library staff.
To initiate this process, we need to get a feel for how the system will interact with the enduser. We assume that some kind of a user-interface is required, so that when the system is
started, it provides a menu with the following choices:
1. Add a member.
2. Add books.
3. Issue books.
4. Return books.
5. Remove books.
6. Place a hold on a book.
7. Remove a hold on a book.
8. Process Holds: Find the first member who has a hold on a book.
9. Renew books.
10. Print out a member’s transactions.
11. Store data on disk.
12. Retrieve data from disk.
13. Exit.
The above menu gives us the list of ways in which the system is going to be used. There are
some implicit requirements associated with these operations. For instance, when a book is
checked out, the system must output a due-date so that the clerk can stamp the book. This
and other such details will be spelled out when we elaborate on the use cases.
The actors in our system are members of the library staff who manage the daily operations.
This idea is depicted in the use case diagram in Figure 4.1, which gives an overview of the
system’s usage requirements. Notice that even in the case of issuing books, the functionality
is invoked by a library staff member, who performs the actions on behalf of a member.
10
Add Member
Add Book
Issue Books
Actor
Return Books
Print Transactions
Remove Books
Place Hold
Remove Hold
Process Holds
Renew Books
Save Data
Retrieve Data
Exit
Figure 4.1: Use Case Diagram for the Library System
11
4.2.2 Detailed Use Cases for the Library System
We now take up the task of specifying the individual use cases. In order to keep the discussion
within manageable size and not lose focus, we make the following assumption: While the use
cases will state the need for the system to display different messages prompting the user
for data and informing the results of operations, the user community is not fussy about the
minute details of what the messages should be; any meaningful message is acceptable. For
example, we may specify in a use case that the system “informs the clerk if the member was
added.” The actual message could be any one of a number of possibilities such as “Member
added,” or “Member registered,” etc.
Use Case for Registering a User Our first use case is for registering a new user and is
given in Table 4.1.
Actions performed by the actor Responses from the system
1. The customer fills out an application
form containing the customer’s name, address, and phone number and gives this to
the clerk.
2. The clerk issues a request to add a new
member.
3. The system asks for data about the new
member.
4. The clerk enters the data into the system.
5. Reads in data, and if the member can
be added, generates an identification number (which is not necessarily a number
in the literal sense just as social security
numbers and phone numbers are not actually numbers) for the member and remembers information about the member.
Informs the clerk if the member was added
and outputs the member’s name, address,
phone, and id.
6. The clerk gives the user his identification number.
Table 4.1: Use case Register New Member
This example illustrates several aspects that all use cases must exhibit.
1. Every use case has to be identified by a name. We have given the name Register New
Member to this use case.
12
2. It should represent a reasonably-sized activity in the organization. It is important
to note that not all actions and operations should be identified as use cases. As an
extreme example, stamping a due-date on the book should not be a use case. A use
case is a relatively large end-to-end process description that captures some business
process that a client purchasing the software needs to perform. In some instances, a
business process may be decomposed into more than one use case, particularly when
there is some intervening real-world event(s) for which the agent has to wait for an
unspecified length of time. An example of such a situation is presented later in this
chapter.
3. The first step of the use case specifies a “real-world” action that triggers the exchange
described in the use case. This is provided mainly for the sake of completeness and
does not have much bearing on the actual design of the system. It does, however, serve
a useful purpose: by looking at the first steps of all the use cases, we can verify that all
external events that the system needs to respond to have been taken care of.
4. The use case does not specify how the functionality is to be implemented. For example,
the details of how the clerk enters the required information into the system are left
unspecified. Although we assume that the user interacts with the system through
the menu, which was briefly described earlier, we do not specify the details of this
mechanism. The use case also does not state how the system accomplishes the task of
registering a user: what software components form the system, how they may interact,
etc.
5. The use case is not expected to cover all possible situations. While we would expect
that the sequence of events that are specified in the above use case is what would
actually happen in a library when a person wants to be registered, the use case does
not specify what the system should do if there are errors. In other words, the use case
explains only the most commonly-occurring scenario, which is referred to as the main
flow. Deviations from the main flow due to occurrences of errors and exceptions are
not detailed in the above use case.
Use Case for Adding Books Next, we look at the use case for adding new books in
Table 4.2 Notice that we add more than one book in this use case, which involves a repetitive
process captured by a go-to statement in the last step. Notice that details of how the identifier
is generated are not specified. From the point of view of the system analyst, this is something
that the actor is expected to take care of independently.
Use Case for Issuing Books Consider the use case where a member comes to the checkout counter to issue a book. The user identifies himself/herself to a clerk, who checks out
the books for the user. It proceeds as in Table 4.3 There are some drawbacks to the way
this use case is written. One drawback is that it does not specify how due-dates are computed. We may have a simple rule (example: due-dates are one month from the date of
issue) or something quite complicated (example: due-date is dependent on the member’s
history, how many books have been checked out, etc.). Including these details in the use case
may make it messy and harder to understand; they are therefor documented separately as
13
Actions performed by the actor Responses from the system
1.Library receives a shipment of books
from the publisher.
2. The clerk issues a request to add a new
book.
3. The system asks for the identifier, title,
and author name of the book.
4. The clerk generates the unique identifier, enters the identifier, title, and author
name of a book.
5. The system attempts to enter the information in the catalog and echoes to the
clerk the title, author name, and id of the
book. It then asks if the clerk wants to
enter information about another book.
6. The clerk answers in the affirmative or
in the negative.
7. If the answer is in the affirmative, the
system goes to Step 3. Otherwise, it exits.
Table 4.2: Use case Adding New Books
Business Rules. Keeping them separate also has the advantage that they can be updated
independently. .
We will refer to the rule for due-date generation as Rule 1. Let us document all the business
rules for our system before we proceed. These are shown in Table 4.5.
A second drawback with the use case is that as written above, it does not state what to do
in case things go wrong. For instance,
1. The person may not be a member at all. How should the use case handle this situation?
We could abandon the whole show or ask the person to register.
2. The clerk may have entered an invalid book id.
To take care of these additional situations, we modify the use case as given in Table 4.4.
We have resolved these issues in Step 7 by having the system check whether the book is
issuable, which can be expressed as a business rule. This could check one (or more) of several
conditions: Is the member in good standing with the library? Is there some reason the book
should not be checked out? Has the member checked out more books than permitted (if such
limits were to be imposed)? The message displayed by the system in Step 7 informs the clerk
about the result of the transaction. In a real-life situation, the client will probably want
specific details of what went wrong; If they are important to the client, these details should
be expressed in the use case. Since our goal is to cover the basics of requirements analysis,
14
Actions performed by the actor Responses from the system
1. The member arrives at the check-out
counter with a set of books and supplies
the clerk with his/her identification number.
2. The clerk issues a request to check out
books.
3. The system asks for the user id.
4. The clerk inputs the user ID to the
system.
5. The system asks for the ID of the book.
6. The clerk inputs the ID of a book that
the user wants to check out.
7. The system records the book as having
been issued to the member; It also records
the member as having possession of the
book. It generates a due-date. The system displays the book title and due-date
and asks if there are any more books.
8. The clerk stamps the due-date on the
book and replies in the affirmative or negative.
9. If there are more books, the system
moves to Step 5; otherwise it exits.
10. The customer collects the books and
leaves the counter.
Table 4.3: Use case Book Checkout
15
we sidestep the issue.
Let us proceed to write more use cases. For the most part, these are quite elementary, and
we suggest that the reader try them first as an exercise.
Use Case for Returning Books Users return books by leaving them on a library clerk’s
desk; the clerk enters the book ids one by one to return them. Table 6.5 gives the details
of the use case. Here, as in the use case for issuing books, the clerk may enter incorrect
information into the system, which the use case handles. Notice that if there is a hold on the
book, that information is printed for use by the clerk at a later time.
Use Cases for Removing (Deleting) Books, Printing Member Transactions, Placing a Hold, and Removing a Hold The next four use cases deal with the scenarios for
removing books (Table 4.7), printing out member transactions (Table 4.2.2), placing a hold
(Table 4.9), and removing a hold (Table 4.10). In the second of these, the system does not
actually print out the transactions, but only displays them on the interface. We are assuming
that the necessary facilities to print will be a part of the underlying platform.
In Step 5 of Table 4.7, we allow for the possibility that the deletion may fail. In this event, we
assume that there will be some meaningful error message so that the clerk can take corrective
action. We shall revisit this issue when we discuss the design and implementation in later
chapters.
There may be some variations in the way these scenarios play out. When placing or removing
a hold, the library staff may actually want to see a message that the operation was successfully
completed. These requirements would modify the manner in which the system responds in
these use cases. While such information should be gleaned from the client as part of the
requirements analysis, it is often necessary to go back to the client after the use cases are
written, to ensure that the system interacts in the desired manner with the operator.
Use Case for Processing Holds Given in Table 4.11, this use case deals with processing
the holds at the end of each day. In this case, once the contact information for the member
has been printed out, we assume that the library will contact the member. The member may
not come to collect the book within the specified time, at which point the library will try
to contact the next member in line. All this cannot be included in the use case. If we were
to do so, the system would, in essence, be waiting on the user’s response for a long period
of time, and the process would not be temporally cohesive. Also, since our proposed system
is not expected to have the ability to contact the members, and we cannot add this to the
system responsibilities. We therefore leave out these steps and when the next user has to be
contacted, we simply process holds on the book once again.
Use Case for Renewing Books This use case (see Table 4.12) deals with situations
where a user has several books checked out and would like to renew some of these. The user
may not remember the details of all of them and would perhaps like the system to prompt
him/her. We shall assume that users only know the titles of the books to be renewed (they
do not bring the books or even the book ids to the library) and that most users would have
borrowed only a small number of books. In this situation, it is entirely appropriate for the
system to display the title of each book borrowed by the user and ask if that book should be
renewed.
16
Actions performed by the actor Responses from the system
1. The member arrives at the check-out
counter with a set of books and supplies
the clerk with his/her identification number.
2. Clerk issues a request to check out
books.
3. The system asks for the user id.
4. Clerk inputs the user ID to the system.
5. If the ID is valid, the system asks for
the ID of the book; otherwise it prints
an appropriate message and exits the use
case.
6. The clerk inputs the identifier of a book
that the user wants to check out.
7. If the ID is valid and the book is issuable to the member, the system records
the book as having been issued to the
member; It records the member as having possession of the book and generates
a due-date as in Rule 1. It then displays
the book’s title and due-date. If the book
is not issuable as per Rule 2, the system
displays a suitable error message. The system asks if there are more books.
8. The clerk stamps the due-date, prints
out the transaction (if needed) and replies
positively or negatively.
9. If there are more books for checking
out, the system goes back to Step 5; otherwise it exits.
10. The clerk stamps the due date and
gives the user the books checked out. The
customer leaves the counter.
Table 4.4: Use case Book Checkout (Revised)
17
How do Business Rules relate to use cases?
Business Rules can be broadly defined as the details through which a business implements its strategy. Business analysts perform the task of gathering business rules,
and these belong to one of four categories:
• Definitional rules, which explain what is meant when a certain word is used
in the context of the business operations. These may include special technical
terms, or common words that have a particular significance for the business.
For instance the term Book in the context of the library refers to a book owned
by the library.
• Factual rules, which explain basic things about the business’s operations;
they tell how the terms connect to each other. A library, for instance, would
have rules such as “Books are issued to Members,” and “Members can place
holds on Books.”
• Constraints, which are specific conditions that govern the manner in which
terms can be connected to each other. For instance, we have a constraint that
says “Holds can be placed only on Books that are currently checked out.”
• Derivations, which are knowledge that can be derived from the facts and
constraints. For instance, a bank may have the constraint, “The balance in an
account cannot be less than zero,” from which we can derive that if an amount
requested for withdrawal is more than the balance, then the operation is not
successful.
When writing use cases, we are mainly concerned with constraints and derivations.
Typically, such business rules are in-lined with the logic of the use-case. The use-case
may explicitly state the test that is being performed and cite the appropriate rule
or may simply mention that the system will respond in accordance with a specific
rule.
In addition to the kinds of rules we have presented for this case study, there are
always implicit rules that permeate the entire system. A common example of this is
validation of input data; a zip code, for instance, can be validated against a database
of zip-codes. Note that this rule does not deal with how entities are connected to one
another, but specifies the required properties of a data element. Such constraints do
not belong in use cases, but could be placed in classes that store the corresponding
data elements.
Figure 4.2: Role of business rules in the analysis process
18
Rule Number Rule
Rule 1 Due-date for a book is one month from the date of issue.
Rule 2 All books that are not already issued are issuable.
Rule 3 A book is removable if it is not checked out and if it has no holds.
Rule 4 A book is renewable if it has no holds on it.
Rule 5 When a book with a hold is returned, the appropriate member will be notified.
Rule 6 Holds can be placed only on books that are currently checked out.
Table 4.5: Business Rules for the Library System
It may be the case that a library has additional rules for renewability: if a book has a hold
or a member has renewed a book twice, it might not be renewable. In the above interaction,
the system displays all the books and determines the renewability only if the member wishes
to renew the book. A different situation could arise if we require that the system display
only the renewable books. (The system would have to have a way for checking renewability
without actually renewing the book, which places additional requirements on the system’s
functionality.) For our simple library, we go with the scenario described in the above table.
4.3 Defining Conceptual Classes and Relationships
As we discussed earlier, the last major step in the analysis phase involves the determination
of the conceptual classes and the establishment of their relationships. For example, in the
library system, some of the major conceptual classes include members and books. Members
borrow books, which establishes a relationship between them.
We could justify the usefulness of this step in at several ways:
1. Design Facilitation. Via use case analysis, we determined the functionality required
of the system. Obviously, the design stage must determine how to implement the
functionality. For this, the designers should be in a position to determine the classes
that need to be defined, the objects to be created, and how the objects interact. This
is better facilitated if the analysis phase classifies the entities in the application and
determines their relationships.
2. Added Knowledge. The use cases do not completely specify the system. Some of
these missing details can be filled in by the class diagram.
3. Error Reduction. In carrying out this step, the analysts are forced to look at
the system more carefully. The result can be shown to the client who can verify its
correctness.
4. Useful documentation. The classes and relationships provide a quick introduction
to the system for someone who wants to learn it. Such people include personnel who
join the project to carry out the design or implementation or subsequent maintenance
of the system.
In practice, an analyst will probably use multiple methods to come up with the conceptual
classes and their relationships. In this case study, however, we use a simple approach: we
examine the use cases and pick out all the nouns in the description of the requirements. We
19
Actions performed by the actor Responses from the system
1. The member arrives at the return
counter with a set of books and leaves
them on the clerk’s desk.
2. The clerk issues a request to return
books.
3.The system asks for the identifier of the
book.
4. The clerk enters the book identifier.
5. If the identifier is valid, the system
marks that the book has been returned
and informs the clerk if there is a hold
placed on the book; otherwise it notifies
the clerk that the identifier is not valid. It
then asks if the clerk wants to process the
return of another book.
6. The clerk answers in the affirmative or
in the negative and sets the book aside in
case there is a hold on the book. (See Rule
5.)
7. If the answer is in the affirmative, the
system goes to Step 3. Otherwise, it exits.
Table 4.6: Use case Return Book
Actions performed by the actor Responses from the system
1. Librarian identifies the books to be
deleted.
2. The clerk issues a request to delete
books.
3. The system asks for the identifier of the
book.
4. The clerk enters the ID for the book.
5. The system checks if the book can be
removed using Rule 3. if the book can
be removed, the system marks the book
as no longer in the library’s catalog. The
system informs the clerk about the success
of the deletion operation. It then asks if
the clerk wants to delete another book.
6. The clerk answers in the affirmative or
in the negative.
7. If the answer is in the affirmative, the
system goes to Step 3. Otherwise, it exits.
Table 4.7: Use case Removing Books
20
Actions performed by the actor Responses from the system
1. The clerk issues a request to get member transactions.
2. The system asks for the user ID of the
member and the date for which the transactions are needed.
3. The clerk enters the identity of the user
and the date.
4. If the ID is valid, the system outputs information about all transactions
completed by the user on the given date.
For each transaction, it shows the type
of transaction (book borrowed, book returned or hold placed) and the title of the
book.
5. Clerk prints out the transactions and
hands them to the user.
Table 4.8: Use case Member Transactions
Actions performed by the actor Responses from the system
1. The clerk issues a request to place a
hold.
2. The system asks for the book’s ID, the
ID of the member, and the duration of the
hold.
3. The clerk enters the identity of the user,
the identity of the book, and the duration.
4. The system checks that the user and
book identifiers are valid and that Rule 6
is satisfied. If yes, it records that the user
has a hold on the book and displays that;
otherwise, it outputs an appropriate error
message.
Table 4.9: Use case Place a Hold
Actions performed by the actor Responses from the system
1. The clerk issues a request to remove a
hold.
2. The system asks for the book’s ID and
the ID of the member.
3. The clerk enters the identity of the user
and the identity of the book.
4. The system removes the hold that the
user has on the book (if any such hold exists), prints a confirmation and exits.
Table 4.10: Use case Remove a Hold
21
Actions performed by the actor Responses from the system
1. The clerk issues a request to process
holds (so that Rule 5 can be satisfied).
2. The system asks for the book’s ID.
3. The clerk enters the ID of the book.
4. The system returns the name and
phone number of the first member with an
unexpired hold on the book. If all holds
have expired, the system responds that
there is no hold. The system then asks if
there are any more books to be processed.
5. If there is no hold, the book is then
shelved back to its designated location in
the library. Otherwise, the clerk prints out
the information, places it in the book and
replies in the affirmative or negative.
6. If the answer is yes, the system goes to
Step 2; otherwise it exits.
Table 4.11: Use case Process Holds
then refine the selection through analysis to obtain concepts that deserve to be classes, and
look for the relationships between them.
4.3.1 Conceptual Classes for the Library System
Let us start with the text of the first use case, registering new users, and pick out the nouns.
Here is the text of that use case, once again, with all nouns bold-faced:
1) The customer fills out an application form containing the customer’s
name, address, and phone number and gives this to the clerk. 2) The clerk
issues a request to add a new member. 3) The system asks for data about the
new member. 4) The clerk enters the data into the system. 5) Reads in data,
and if the member can be added, generates an identification number for the
member and remembers information about the member. Informs the clerk
if the member was added and outputs the member’s name, address, phone,
and id. 6) The clerk gives the user his identification number.
Let us examine the nouns. First, let us eliminate duplicates to get the following list: customer, application form, customer’s name, address, phone number, clerk, request,
system, data, identification number, member, user, member information, and
member’s name. Some of the nouns such as member are composite entities that qualify
to be classes.
While using this approach, we must remember that natural languages are imprecise and that
synonyms may be found. We can eliminate the others as follows:
1. customer: becomes a member, so it is effectively a synonym for member.
2. user: the library refers to members alternately as users, so this is also a synonym.
22
Actions performed by the actor Responses from the system
1. Member makes a request to renew several of the books that he/she has currently
checked out.
2. Clerk issues a request to renew books.
3. System asks for the member’s ID.
4. The clerk enters the ID into the system.
5. System checks the member’s record
to find out which books the member has
checked out. If there are none, the system
prints an appropriate message and exits;
otherwise it moves to Step 6.
6. The system displays the title of the
next book checked out to the member and
asks whether the book should be renewed.
7. The clerk replies yes or no.
8. The system attempts to renew the book
using Rule 4 and reports the result. If
the system has displayed all checked-out
books, it reports that and exits; otherwise
the system goes to Step 6.
Table 4.12: Use case Renew Books
23
3. application form and request: application form is an external construct for gathering
information, and request is just a menu item, so neither actually becomes part of the
data structures.
4. customer’s name, address, and phone number: They are attributes of a customer,
so the Member class will have them as fields.
5. clerk: is just an agent for facilitating the functioning of the library, so it has no software
representation.
6. identification number: will become part of a member.
7. data: gets stored as a member.
8. information: same as data related to a member.
9. system: collective reference to all the entities that help track the necessary information.
The noun system implies a conceptual class that represents all of the software; we call
this class Library. Although we do not have as yet any specifics of this class, we note its
existence and represent it in UML without any attributes and methods (Figure 4.3). (Recall
from Chapter 2 that a class is represented by a rectangle.)
A member is described by the attributes name, address, and phone number. Moreover, the
system generates an identifier for each user, so that also serves as an attribute. The UML
convention is to write the class name at the top with a line below it and the attributes listed
just below that line. The UML diagram is shown in Figure 4.4. Obviously, members and
books are the most central entities in our system: the sole reason for the library’s existence
is to provide service to its members and that is effected by letting them borrow books. Just
as we reasoned for the existence of a conceptual class named Member, we can argue for the
need of a conceptual class called Book to represent a book. It has attributes id, title, and
author. A UML description of the class is shown in Figure 4.5.
4.3.2 Identifying the Relationships Between the Classes
Recall the notion of association between classes, which we know from Chapters 2 and 3 as
a relationship between two or more classes. We note several examples of association in our
case study. The use case Register New Member (Table 6.1) says that the system “remembers
information about the member.” This implies an association between the conceptual classes
Library and Member. This idea is shown in Figure 4.6; note the line between the two classes
and the labels 1, *, and “maintains a collection of” just above it. They mean that one
instance of the Library maintains a collection of zero or more members.
It should come as no surprise that an association between the classes Library and Book,
shown in Figure 4.7, is also needed. We show that a library has zero or more books. (Normally,
you would expect a library to have at least one book and at least one member; But our design
takes no chances!)
Some associations are static, i.e., permanent, whereas others are dynamic. Dynamic associations are those that change as a result of the transactions being recorded by the system.
Such associations are typically associated with verbs.
As an example of a dynamic association, consider members borrowing books. This is an
association between Member and Book, shown in Figure 4.8. At any instant in time, a book
24
Guidelines to remember when writing use cases.
• A use case must provide something of value to an actor or the business; when
the scenario described in the use case has played out, the actor has accomplished some task. The system may have other functions that do not provide
value; these will be just steps within a use case. This also implies that each
use case has at least one actor.
• Use cases should be functionally cohesive, i.e., they encapsulate a single service
that the system provides.
• Use cases should be temporally cohesive. This notion applies to the time
frame over which the use case occurs. For instance, when a book with a hold is
returned, the member who has the hold needs to be notified. The notification is
done after some delay; due to this delay, we do not combine the two operations
into one use case. Another example could be a university registration system -
when a student registers for a class, he or she should be billed. Since the billing
operation is not temporally cohesive with the registration, the two constitute
separate use cases.
• If a system has multiple actors, each actor must be involved in at least one,
and typically several use cases. If our library allowed members to check out
books by themselves, “member” is another possible actor.
• The model that we construct is a set of use cases, i.e., there is no relationship
between individual use cases.
• Exceptional exit conditions are not handled in use cases. For instance, if a
system should crash in the middle of a use case, we do not describe what the
system is supposed to do. It is assumed that some reasonable outcome will
occur.
• Use cases are written from the point of view of the actor in the active voice.
• A use case describes a scenario, i.e., tells us what the visible outcome is and
does not give details of any other requirements that are being imposed on the
system.
• Use cases specify the functionality of the system. Hence we should ensure that
we have the technology needed to handle the stated responsibilities.
25
Library
Figure 4.3: UML diagram for the class Library
Member
name
address
id
phone
Figure 4.4: UML diagram for the class Member
Book
title
author
id
Figure 4.5: UML diagram for the class Book
Member
name
address
id
phone
Library maintains a collection of
 1 *
Figure 4.6: UML diagram showing the association of Library and Member
Book
title
author
id Library maintains a collection of
 1
*
Figure 4.7: UML diagram showing the association of Library and Book
26 Book
title
author
has borrowed * id
Member
name
address
id
phone
 1
Figure 4.8: UML diagram showing the association Borrows between Member and Book
Book
title
author
has placed hold on * id
Member
name
address
id
phone
*
Figure 4.9: UML diagram showing the association Holds between Member and Book
can be borrowed by one member and a member may have borrowed any number of books. We
say that the relationship has borrowed is a one-to-many relationship between the conceptual
classes Member and Book and indicate it by writing 1 by the side of the box that represents
a user and the * near the box that stands for a book.
This diagram actually tells us more than what the Issue Book use case does. That use case
does not say some of the considerations that come into play when a user borrows a book: for
example, how many books a user may borrow. We might have forgotten to ask that question
when we learned about the use case. But now that we are looking at the association and are
forced to put labels at the two ends, we may end up capturing missing information. In the
above diagram, we state that there is no limit. It also states that two users may not borrow
the same book at the same time. This is a dynamic relationship. When a member borrows
books, the corresponding member object and the corresponding book objects get associated
in this way. When a member returns books, the associations are removed.
Another action that a member can undertake is to place a hold on a book. Several users can
have holds placed on a book, and a user may place holds on an arbitrary number of books.
In other words, this relationship is many-to-many between users and books. We represent
this in Figure 4.9 by putting a * at both ends of the line representing the association.
We capture all of the conceptual classes and their associations into a single diagram in Figure
4.10. To reduce complexity, we have omitted the attributes of Library, Member, and Book.
As seen before, a relationship formed between two entities is sometimes accompanied by
additional information. This additional information is relevant only in the context of the
relationship. There are two such examples in the inter-class relationships we have seen so
far: when a user borrows a book and when a user places a hold on a book. Borrowing a book
introduces new information into the system, viz., the date on which the book is due to be
returned. Likewise, placing a hold introduces some information, viz., the date after which the
27
Book
Library
maintains a collection of
 1
 *
Member
 1
 *
has placed
hold on
maintains a collection of
has
borrowed
Borrows
dueDate
Holds
date

*

*

*
 1
Figure 4.10: Conceptual Classes and their Associations for the Library System
28
book is not needed. The lines representing the association are augmented to represent the
information that must be stored as part of the association. For the association Borrows and
the line connecting Member and Book, we come up with a conceptual class named Borrows
having an attribute named dueDate. Similarly, we create a conceptual class named Holds
with the attribute called date to store the information related to the association Holds. Both
these conceptual classes are attached to the line representing the corresponding associations.
It is important to note that the above conceptual classes or their representation do not, in
any way, tell us how the information is going to be stored or accessed. Those decisions will
be deferred to the design and implementation phase. For instance, there may be additional
classes to support the operations of the Library class. We may discover that while some
of the conceptual classes have corresponding physical realizations, some may disappear and
the necessary information may be stored as fields distributed over multiple classes. We may
choose to move fields that belong to an association elsewhere. For instance, the field dueDate
may be stored as a field of the book or as a separate object, which holds a reference to the
book object and the user object involved. Upon making that choice, the designer decides
how the conceptual relationship between User and Book is going to be physically realized.
The conceptual class diagram is simply that: conceptual.
4.4 Using the Knowledge of the Domain
Domain analysis is the process of analyzing related application systems in a domain so as
to discover what features are common between them and what parts are variable. In other
words, we identify and analyze common requirements from a specific application domain. In
contrast to looking at a certain problem completely from scratch, we apply the knowledge
we already have from our study of similar systems to speed up the creation of specifications,
design, and code. Thus one of the goals of this approach is reuse.
Any area in which we develop software systems qualifies to be a domain. Examples include
library systems, hotel reservation systems, university registration systems, etc. We can sometimes divide a domain into several interrelated domains. For example, we could say that the
domain of university applications includes the domain of course management, the domain of
student admissions, the domain of payroll applications, and so on. Such a domain can be
quite complex because of the interactions of the smaller domains that make up the bigger
one.
Before we analyze and construct a specific system, we first need to perform an exhaustive
analysis of the class of applications in that domain. In the domain of libraries, for example,
there are things we need to know including the following.
1. The environment, including customers and users. Libraries have loanable items such as
books, CDs, periodicals, etc. A library’s customers are members. Libraries buy books
from publishers.
2. Terminology that is unique to the domain: for example, The Dewey Decimal Classification (DDC) System for books.
3. Tasks and procedures currently performed. In a library system, for example:
(a) Members may check out loanable items.
(b) Some items are available only for reference; they cannot be checked out.
29
Domain
Analysis
Existing Software
Interviews
Surveys
Literature Better Models
Quicker development
Better Design
Anticipate Extensions
Figure 4.11: Domain Analysis: Inputs and Potential Benefits
(c) Members may put holds on loanable items.
(d) Members will pay a fine if they return items after the due date.
One of the major activities of this analysis is discovering the business rules, the rules that
any properly-functioning system in that domain must conform to.
Where does the knowledge of a specific domain come from? It could be from sources such as
surveys, existing applications, technical reports, user manuals, and so on. As shown in Figure
4.11, domain analysis uses this knowledge to improve the design of the resulting system.
30
Finding the right classes. In general, finding the right classes is non-trivial. It
must be remembered that this process is iterative, i.e., we start with a set of classes,
and complete a conceptual design. In the process of walking through the use case
implementations, we may find that some classes have to be dropped and some others
have to be added. Familiarity with Design Patterns also helps in recognizing the
classes. The following thumb rules and caveats come in handy:
• In general, do not build classes around functions. Write a class description. If
it reads “This class performs...” we most likely have a problem. If class name
is imperative e.g. print, parse, etc. it is likely that either the class is wrong or
the name is wrong.
• Remember that a class usually has more than one method; otherwise it is
probably a method that should be attached to some other class.
• Do not form an inheritance hierarchy too soon unless we have a preexisting taxonomy. (Inheritance is supposed to be a relationship among wellunderstood abstractions.)
• Be wary of classes that have no methods, (or only query methods) because
they are not frequent. Some situations in which they occur are:
(i) Representing objects from outside world (ii) Encapsulating facilities, constants or shared variables. (iii) Applicative classes used to describe nonmodifiable objects e.g. Integer class in Java generates new integers, but does
not allow modification of integers.
• Check for the following properties of the ideal class: (i) A clearly associated abstraction, which should be a data abstraction (as opposed to a process abstraction). (ii) A descriptive noun/adjective for the class name. (iii) A non-empty
set of runtime objects. (iv) Queries and commands. (v) Abstract properties
that can be described as pre/post conditions and invariants.
Clearly, a significant amount of effort has to be expended to domain analysis before undertaking the specific problem. The benefit is that after the initial investment of resources, the
products (such as specifications, designs, code, test data, etc.) can be reused for the development of any number of applications in that domain. This reduces development time and
cost.
4.5 Discussion and Further Reading
A detailed treatment of object-oriented analysis methods can be found in [4]. The rules for
finding the right classes are condensed from [5].
Obtaining the Requirements Specification is typically part of a larger “Plan and Elaborate
Phase” that would be an essential component of any large project. In addition to specification
of requirements, this phase includes such activities as the initial conception, investigation
31
of alternatives, planning, budgeting etc. The end product of this phase will include such
documents as the Plan showing a schedule, resources, budget etc., a Preliminary Investigation
Report that lists the motivation, alternatives, and business needs, Requirements Specification,
a Glossary as an aid to understanding the vocabulary of the domain, and, perhaps, a rough
Conceptual Model. Larger systems typically require more details before the analysis can
proceed.
Use case modeling is one of the main techniques of a more general field of study called Usage
Modeling. Usage Modeling employs the following techniques: Essential use cases, System use
cases, UML use case diagrams, User stories and Features [1]. What we have discussed here
are essential use cases, which deal only with the fundamental business task without bringing
technological issues into account. These are used to explore usage-based requirements.
Making sure that our use cases have covered all the business processes is in itself a non-trivial
task. This area of study, called Business Process Modeling employs tools such as Data Flow
Diagrams, Flowcharts, and UML Activity Diagrams, [1] and is used to create process models
for the business.
There are several UML tools available for analysis, and new variants are being constantly
developed. What a practitioner chooses often depends on the development package being
employed. A good, compact reference to the entire language can be found in [3]. The use
case table and the class diagram with associations exemplify the very basic tools of objectoriented analysis.
There is no prescribed analysis or design technique that software designer must follow at
all costs. There are several methodologies in vogue, and these ideas continue to evolve over
time. In [2] it has been pointed out that while some researchers and developers are of the
opinion that object-oriented methodologies are a revolutionary change from the conventional
techniques, others have argued that object-oriented techniques are nothing but an elaboration of structured design. A comparative study of various object-oriented and conventional
methodologies is also presented in that article.
32
The Object-Oriented Analysis Process
The object-oriented analysis process explained in this chapter can be captured by the
following figure:
Requirements
Gathering and
Problem
Definition
Functional
Requirements
Non-Functional
Requirements
Object-oriented
Analysis
Conceptual
Model
User-Interaction
Model
When a piece of software has to be created, we go through a process of gathering requirements and defining the problem. This task is carried out as part of any good problem
solving or software engineering process. This process is not specific to object-oriented
analysis, and is not within the scope of this book. This process produces two artifacts,
the functional requirements and the non-functional requirements.
Our focus in this book is mainly on the functional requirements, which can be expressed
as a set of business processes. The object-oriented analysis process that we describe here
starts with this artifact. It is important that these business processes be defined clearly
enough for our purpose, which means the person doing the object-oriented analysis must
recognize when the businesses processes are poorly written.
Our object-oriented process uses the functional requirements to generate the userinteraction model and the conceptual model. The user-interaction model defines how
the system responds to the various inputs, and is captured in the detailed use cases. Such
a model of a system is useful for any kind of design process.
The conceptual model identifies the particular concepts specific to such a system, and the
nature of the relationships between these concepts. These concepts are the conceptual
classes that define the types of objects that our system will need, and are the building
blocks for the object-oriented design process.
4.6 Projects
1. A database for a warehouse
A large warehousing corporation operates as follows:
33
(a) The warehouse stocks several products, and there are several manufacturers for
each product.
(b) The warehouse has a large number of registered clients. The clients place orders
with the warehouse, which then ships the goods to the client. This process is as
follows: The warehouse clerk examines the client’s order and creates an invoice,
depending on availability of the product. The invoice is then sent to the shop floor
where the product is packed and shipped along with the invoice. The unfilled part
of the order is placed in a waiting list queue.
(c) When the stock of any product runs low, the warehouse orders that product from
one of the manufacturers, based on the price and terms of delivery.
(d) When a product shipment is received from a manufacturer, the orders in the
waiting list are filled in first. The remainder is added to the inventory.
The Business Processes. The warehouse has three main operational business processes:
(a) Receiving and processing an order from a client.
(b) Placing an order with the manufacturer.
(c) Receiving a shipment.
(d) Receiving payment from a client.
Let us examine the first of these. When an order is received from a client the following
steps are involved:
(a) Clerk receives the order and enters the order into the system.
(b) The system generates an invoice based on the availability of the product(s).
(c) The clerk prints the invoice and sends it over to the storage area.
(d) A worker on the floor picks up the invoice, retrieves the product(s) from the shelves
and packs them, and ships the goods and the invoice to the client.
(e) The worker requests the system to mark the order as having been shipped.
(f) The system updates itself by recording the information.
This is an interesting business process because of the fact that steps of printing the
invoice and retrieving the product from the shelves are performed by different actors.
This introduces an indefinite delay into the process. If we were to translate this into a
single end-to-end use case, we have a situation where the system will be waiting for a
long time to get a response from an actor. It is therefore appropriate to break this up
into two use cases as follows:
1. Use case create-invoice.
2. Use case fill-invoice.
In addition to these operational business processes, the warehouse will have several
other querying and accounting processes such as:
(a) Registering a new client.
(b) Adding a new manufacturer for a certain product.
34
(c) Adding a new product.
(d) Printing a list of clients who have defaulted on payments.
(e) Printing a list of manufacturers who are owed money by the warehouse etc.
Write the use cases, and determine the conceptual classes and their relationships.
2. Managing a university registration system.
A small university would like to create a registration system for its students. The
students will use this system to obtain information about courses, when and where the
classes meet, register for classes, print transcripts, drop classes etc. Faculty will be
using this system to find out what classes they are assigned to teach, when and where
these classes meet, get a list of students registered for each class, and assign grades to
students in their classes. The university administrative staff will be using this database
to add new faculty and students, remove faculty and students who have left, put in
and update information about each course the university offers, enter the schedules for
classes that are being offered in each term, and any other housekeeping tasks that need
to be performed.
Your task is to analyze this system, extract and list the details of the various business
processes, develop the use cases, and find the conceptual classes and their relationships.
In finding the classes for this system, one of the issues that comes up is that of distinguishing a course from an offering of the course. For instance “CS 430: Principles
of Object-Oriented Software Construction” is a course listed in the university’s course
bulletin. The course is offered once during the fall terms and once during the spring
term. Each offering may be taught at a different time and place, and in all likelihood
will have a different set of students. Therefore all offerings have some information in
common and some information that is unique to that offering. How will you choose a
set of classes that models all these interactions?
3. Creating an airline reservation and staff scheduling database.
An airline has a weekly flight schedule. Associated with each flight is an aircraft, a
list of crew, and a list of passengers. The airline would like to create and maintain a
database that can perform the following functions:
For passengers: Add a passenger to the database, reserve a seat on a flight, print out
an itinerary, request seating and meal preferences, and update frequent flier records.
For crew: Assign crew members to each flight, allow crew members to view their schedule, keep track of what kinds of aircraft the crew member has been trained to operate.
For flights: Keep track of crew list, passenger list, and aircraft to be used for that flight.
For aircraft: Maintain all records about the aircraft and a schedule of operation.
Make an exhaustive list of queries that this system may be required to answer. Carry
out a requirements analysis for the system and model it as a collection of use cases.
Find the conceptual classes and their relationships.
35
4.7 Exercises
1. In the use case Issue Book the system displays the transaction details with each book.
Modify this so that there is only one display of transactions at the very end of the
process.
2. (Discussion) In a real library, there would be several other kinds of query operations
that would be performed. Carry out a brainstorming exercise to come up with a more
complete list of use cases for a real library system.
3. A Hotel Reservation System supports the following functionality:
(a) Room reservation
(b) Changing the properties of a room (for example, from non-smoking to smoking)
(c) Customer check-in
(d) Customer check-out
Come up with system use cases for the above functionality.
4. We are building a system to track personal finances. We plan an initial version with
minimal functionality: we track the expenditures. (Each expenditure has a description,
date, and amount.) We show below the use case for creating a new expenditure item
and a new income item.
Actor System
1) Inputs a request to create a
new expenditure item
2) Asks for description, date,
and amount
3) Supplies the data
4) Creates an expenditure
item and notifies the user
Actor System
1) Inputs a request to create a
new income item
2) Asks for description, date,
and amount
3) Supplies the data
4) Creates an income item and
notifies the user
(a) The use cases are quite weakly specified. In what ways? (Hint: Compare with the
addition of a new member or book in the library system.)
(b) What are the alternate flows in the use cases? Modify the two use cases to handle
the alternate flows.
(c) Identify the conceptual classes.
5. Consider the policies maintained by an automobile insurance company. A policy has a
primary policy holder, a set of autos insured, and a list of people who are covered by
the insurance. From your knowledge of insurance, come up with system use cases for
36
(a) creating a new policy
(b) adding a new person to a policy
(c) adding a new automobile to a policy
(d) recording a claim.
6. Consider an information system to be created for handling the business of a supermarket. For each of the following, state if it is a possible class. If not, explain why not.
Otherwise, why would you consider it to be a class? What is its role in the system?
(a) Customer
(b) Vegetable
(c) Milk
(d) Stock
(e) Canned food
(f) Quantity on hand for a product
7. A company has several projects, and each employee works in a single project. The
human resource system evaluates the personnel needs of each project and matches
them against the personnel file to find the best possible employees to be assigned to
the project. Come up with the conceptual classes by conducting use case analysis.
8. Explain why mistakes made in the requirements analysis stage are the costliest to
correct.
9. Among the following requirements, which are functional and which are non-functional?
(a) Paychecks should be printed every two weeks.
(b) Database recovery should not take more than one hour.
(c) The system should be implemented using the C++ language.
(d) It should be possible to selectively print employee checks.
(e) Employee list should be displayed in lists of size 10.
10. Suppose the library system has to be augmented so that it can support inter-library
loans. That is, a customer can ask the clerk if a certain book, which is not locally
available, is available in some other library. What changes are needed (classes and use
cases) to incorporate this new functionality?
11. In Problem 6, assume that a customer may pay with cash, check, or credit/debit cards.
Should this aspect be taken into consideration while developing the use case for purchasing grocery? Justify your answer.
12. Again, in Problem 6, suppose that a user may check out by interacting with a sales
clerk or independently in an automated checkout counter. Should there be two versions
of the grocery purchase use case? Explain.
13. What are the advantages of ignoring implementation-related aspects while performing
analysis?
Bibliography
[1] S. Ambler. The Object Primer: Agile Model-Driven Development with UML 2.0. Cambridge University Press, 2004.
[2] R. Fichman and C. Kemerer. Object-Oriented and Conventional Analysis and Design
Methodologies. IEEE Computer Society Press, 1995.
[3] M. Fowler and K. Scott. UML Distilled. Addison-Wesley Longman, 1997.
[4] C. Larman. Applying UML and Patterns. Prentice Hall PTR, 1998.
[5] B. Meyer. Object-Oriented Software Construction. Prentice Hall, 1997.
37
Index
Analysis, 5
Business Processes, 7
Business Rules, 13
Conceptual Classes and Relationships, 18
Domain Analysis, 28
Functional Requirements, 6, 8
Non-Functional Requirements, 6
Requirements Gathering, 6
Use Case, 11
Use Case Analysis, 9
Business Processes, 7
Conceptual Classes and Relationships, 18
Conceptual Model, 5
Domain Analysis, 28
Functional Requirements, 6, 8
Non-Functional Requirements, 6
Requirements Analysis, see Analysis
Requirements Gathering, 6
UML
Association, 23
Use Case Diagrams, 9
Use Case, 11
Use Case Analysis, 9
Use Case Diagrams, 9
User-interaction model, 5
38
